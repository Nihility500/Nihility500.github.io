<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nihilityのblog</title>
  
  
  <link href="https://nihility500.github.io/atom.xml" rel="self"/>
  
  <link href="https://nihility500.github.io/"/>
  <updated>2023-04-05T07:21:48.889Z</updated>
  <id>https://nihility500.github.io/</id>
  
  <author>
    <name>Nihility</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql</title>
    <link href="https://nihility500.github.io/2023/04/05/MySql/"/>
    <id>https://nihility500.github.io/2023/04/05/MySql/</id>
    <published>2023-04-05T06:58:00.000Z</published>
    <updated>2023-04-05T07:21:48.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1、初始MySQL"><a href="#1、初始MySQL" class="headerlink" title="1、初始MySQL"></a>1、初始MySQL</h2><p>javaEE：企业级Java开发 Web</p><p>前端（页面：展示，数据！）</p><p>后台（连接到：连接数据库JDBC，链接前端(控制，控制视图跳转，给前端传递数据)</p><p>数据库（存数据，Txt，Excel，word）</p><blockquote><p>操作系统，数据结构与算法！</p><p>离散数学，数字电路，体系结构，编译原理。+实战经验</p></blockquote><h3 id="1-1、为什么学习数据库"><a href="#1-1、为什么学习数据库" class="headerlink" title="1.1、为什么学习数据库"></a>1.1、为什么学习数据库</h3><p>1、 岗位要求</p><p>2、大数据时代</p><p>3、被迫需求：存数据</p><p>4、&#x3D;&#x3D;数据库是所有软件体系种最核心的存在&#x3D;&#x3D; DBA</p><h3 id="1-2、什么是数据库"><a href="#1-2、什么是数据库" class="headerlink" title="1.2、什么是数据库"></a>1.2、什么是数据库</h3><p>数据库（DB，database）</p><p>概念：数据仓库，&#x3D;&#x3D;软件&#x3D;&#x3D;，安装在操作系统（window，Linux，max…）上 （SQL 操作数据库语句)</p><p>作用：存储、管理数据</p><h3 id="1-3、数据库分类"><a href="#1-3、数据库分类" class="headerlink" title="1.3、数据库分类"></a>1.3、数据库分类</h3><p>关系型数据库：(SQL)</p><p>（Excel）</p><ul><li>MySQL，Oracle，Sql Server，DB2，SQLlite</li><li>通过表和表之间，行和列之间的关系进行数据的储存</li></ul><p>非关系数据库：（Not Only SQL)</p><p>（{key，value}）</p><ul><li>Redis，MongDB</li><li>非关系型数据库，对象存储，通过对象的自身的属性来决定。</li></ul><p>&#x3D;&#x3D;DBMS(数据库管理系统)&#x3D;&#x3D;</p><ul><li>数据库的管理软件，科学有效的管理我们的数据。维护和获取数据；</li><li>MySQL 就是数据库管理系统</li></ul><p>开源的数据库软件~</p><p>体积小，速度快，总体拥有成本低，招人成本低，所有人必须会·</p><p>中小型网站、或者大型网站，集群</p><p>5.7稳定</p><p>8.0</p><p>压缩包安装</p><h3 id="1-4、连接数据库"><a href="#1-4、连接数据库" class="headerlink" title="1.4、连接数据库"></a>1.4、连接数据库</h3><p>命令行连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">net <span class="keyword">start</span> mysql<span class="comment">-- 启动服务</span></span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p <span class="comment">--  连接数据库</span></span><br><span class="line">flush privileges;<span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="comment">-- 所有语句结尾都用;结尾</span></span><br><span class="line"><span class="keyword">show</span> databases;<span class="comment">-- 查看数据</span></span><br><span class="line">mysql<span class="operator">&gt;</span>use school <span class="comment">-- 切换数据库 use 数据库名</span></span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> tables;<span class="comment">-- 查看数据库中表</span></span><br><span class="line"><span class="keyword">desc</span> student;<span class="comment">-- 娴熟数据空中所有表的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database westos;<span class="comment">--  创建一个数据库</span></span><br><span class="line">exit;<span class="comment">-- 退出连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="comment">/*(多行注释)</span></span><br><span class="line"><span class="comment">..</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>数据库xxx语言</strong> CRUD增删改查</p><p>DDL  定义</p><p>DML  操作</p><p>DQL  查询</p><p>DCL  控制</p><h2 id="2、操作数据库"><a href="#2、操作数据库" class="headerlink" title="2、操作数据库"></a>2、操作数据库</h2><p>操作数据库&gt;操作数据空中的表&gt;操作数据库中表的数据</p><p>&#x3D;&#x3D;mysql操作不区分大小写&#x3D;&#x3D;</p><h3 id="2-1、操作数据库"><a href="#2-1、操作数据库" class="headerlink" title="2.1、操作数据库"></a>2.1、操作数据库</h3><p>1、创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">creat database [if <span class="keyword">not</span> <span class="keyword">exists</span>] westos;</span><br></pre></td></tr></table></figure><p>2、删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] westos</span><br></pre></td></tr></table></figure><p>3、使用数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use `school`</span><br><span class="line"><span class="comment">-- tab键的上面，如果你的表名或者字段名是一个特殊字符比如user这种重复名，就需要带``</span></span><br></pre></td></tr></table></figure><p>4、查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases <span class="comment">-- suo</span></span><br></pre></td></tr></table></figure><h3 id="备份和修复数据库"><a href="#备份和修复数据库" class="headerlink" title="备份和修复数据库"></a>备份和修复数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p -B 数据库1 数据库2 &gt; 文件名.sql（包含路径） -- 在dos命令好执行</span><br><span class="line">Source 文件名.sql -- 在MySQL执行</span><br></pre></td></tr></table></figure><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename table a to b</span><br></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE emp</span><br><span class="line">ADD image VARCHAR(32) NOT NULL DEFAULT &#x27;&#x27;</span><br><span class="line">AFTER RESUME</span><br><span class="line">DESC emp-- 显示表结构，可以查看表的所有列</span><br></pre></td></tr></table></figure><h3 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE emp</span><br><span class="line">MODIFY job VARCHAR(60) NOT NULL DEFAULT &#x27;&#x27;</span><br><span class="line">ALTER TABLE emp --修改</span><br><span class="line">DROP sex --删除</span><br></pre></td></tr></table></figure><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TBALE emp TO employee</span><br></pre></td></tr></table></figure><h3 id="改变字符集"><a href="#改变字符集" class="headerlink" title="改变字符集"></a>改变字符集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employee CHARACTER SET utf8</span><br><span class="line">ALTER TABLE emoloyee</span><br><span class="line">CHANGE `name` `user_name` VARCHAR(64) NOT NULL DEFAULT &#x27;&#x27; --列的名字被改为user_name</span><br></pre></td></tr></table></figure><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 列名</span><br><span class="line">VALUES (value)</span><br><span class="line">#练习insert 语句</span><br><span class="line">CREATE TABLE `goods`(</span><br><span class="line">id INT,</span><br><span class="line">goods_name VARCHAR(10),</span><br><span class="line">price DOUBLE;</span><br><span class="line">)</span><br><span class="line">INSERT INTO `goods`(id,goods_name,price)</span><br><span class="line">VALUES(10,&#x27;华为手机&#x27;,2000);</span><br><span class="line">INSERT INTO &#x27;goods&#x27;(id,goods_name,price)</span><br><span class="line">VALUES(20,&#x27;vivo手机&#x27;,1500);</span><br><span class="line">SELECT * FROM goods;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>插入数据与字段的数据类型相同。<ul><li>把’abc’天骄到int 类型会错误</li></ul></li><li>数据的长度应在列表的规定范围内<ul><li>不能将一个长度为80的字符串放到长度为40的列中</li></ul></li><li>在values种列出的数据位置必须与被加入的列的排列位置相同</li><li>字符和日期型数据应包含在单引号中。</li><li>列可以插入空值[前提是该字段允许为空]</li><li>insert into tab_name(列名) values (),(),()形式添加多条记录</li><li>如果是给表中的所有字段添加数据，可以不写前面的字段名词<ul><li>INSERT INTO `goods`<del>(1,2,3)</del> VALUES(1,2,3)</li></ul></li><li>默认值的使用，当不给某个字段值是，如果有默认值就会添加，否则就报错；如果某个列没有指定NOT NULL，那么添加数据是，没有给定值，那么默认给NULL；NOT NULL DEFAULT 100 可以改变默认值</li></ol><h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from ..</span><br><span class="line">order by empno -- 按...排序</span><br><span class="line">limit 每页显示的记录数 * （第几页-1）,每页显示的记录数</span><br><span class="line">-- 分页查询</span><br></pre></td></tr></table></figure><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tbl_name</span><br><span class="line">SET col_name1=exprt1[,col_name2=expr2...]-- []内为可选</span><br><span class="line">[where where_definition]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UPDATE employee SET salary = 5000 -- 如果没有代where 条件，会修改所有数据，因此要小心</span><br><span class="line">WHERE user_name =&#x27;野犬&#x27;</span><br><span class="line">INSERT INTO employee</span><br><span class="line">VALUES (200,&#x27;文豪&#x27;,&#x27;1990-11-11&#x27;,&#x27;2022-11-11&#x27;,5000);</span><br><span class="line">UPDATE employee</span><br><span class="line">SET salary = salary + 1000</span><br><span class="line">WHERE user_name = &#x27;老妖怪&#x27;</span><br></pre></td></tr></table></figure><h3 id="Delect"><a href="#Delect" class="headerlink" title="Delect"></a>Delect</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from `table_name`</span><br><span class="line"> WHERE where_definition -- 如果不加where会全部删除</span><br></pre></td></tr></table></figure><h2 id="Select语句"><a href="#Select语句" class="headerlink" title="Select语句"></a>Select语句</h2><h4 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h4><h5 id="使用表达式对查询的列及进行运算"><a href="#使用表达式对查询的列及进行运算" class="headerlink" title="使用表达式对查询的列及进行运算"></a>使用表达式对查询的列及进行运算</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT [distinct] *|&#123;column1,column2&#125;</span><br><span class="line">FROM `table_name`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT columnname as 别名 from 表名;</span><br></pre></td></tr></table></figure><h5 id="在where子句中经常使用的运算符"><a href="#在where子句中经常使用的运算符" class="headerlink" title="在where子句中经常使用的运算符"></a>在where子句中经常使用的运算符</h5><p><img src="/pic/Mysql/1.png" alt="1"></p><h5 id="使用order-by子句排序结果"><a href="#使用order-by子句排序结果" class="headerlink" title="使用order by子句排序结果"></a>使用order by子句排序结果</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1,colum2</span><br><span class="line">FROM table;</span><br><span class="line">order by column asc|desc -- asc升序（默认），desc降序</span><br></pre></td></tr></table></figure><h5 id="Count-返回行的总数"><a href="#Count-返回行的总数" class="headerlink" title="Count 返回行的总数"></a>Count 返回行的总数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(*)|count(列名) from `table_name`</span><br><span class="line">[where where_definition] -- count(*)返回满足条件的记录的行数，count(列)统计满足条件的某列有多少个，但是会排除为 null的情况</span><br></pre></td></tr></table></figure><h5 id="sum返回满足where条件的行的和"><a href="#sum返回满足where条件的行的和" class="headerlink" title="sum返回满足where条件的行的和"></a>sum返回满足where条件的行的和</h5><p>– 一般使用在数值列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select sum(列名)&#123;,sum(列名)...&#125; from tablename</span><br><span class="line">[where where_definition]</span><br></pre></td></tr></table></figure><h5 id="avg返回满足where条件的一列的平均值"><a href="#avg返回满足where条件的一列的平均值" class="headerlink" title="avg返回满足where条件的一列的平均值"></a>avg返回满足where条件的一列的平均值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select avg(列名)&#123;,sum(列名)...&#125; from tablename</span><br><span class="line">[where where_definition]</span><br></pre></td></tr></table></figure><h5 id="max和min"><a href="#max和min" class="headerlink" title="max和min"></a>max和min</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select max(列名)&#123;,sum(列名)...&#125; from tablename</span><br><span class="line">[where where_definition]</span><br></pre></td></tr></table></figure><h5 id="group-by-having"><a href="#group-by-having" class="headerlink" title="group by + having"></a>group by + having</h5><p>使用group by子句对列精选分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column1,column2. column3.. from table group by column</span><br></pre></td></tr></table></figure><p><img src="/pic/Mysql/2.png" alt="2"></p><p>实验having子句对分组后的结果进行过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select column1,column2.column3..</span><br><span class="line">from table group by column having ...</span><br></pre></td></tr></table></figure><p><img src="/pic/Mysql/2.png" alt="3"></p><p>过滤条件可以使用别名</p><h4 id="查询加强"><a href="#查询加强" class="headerlink" title="查询加强"></a>查询加强</h4><p>如果select语句中顺序为 group by，having，order by，limit</p><h5 id="使用where子句"><a href="#使用where子句" class="headerlink" title="使用where子句"></a>使用where子句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from emp</span><br><span class="line">where hiredate &gt; &#x27;1992-10-10&#x27;</span><br></pre></td></tr></table></figure><h5 id="使用like操作符（模糊）"><a href="#使用like操作符（模糊）" class="headerlink" title="使用like操作符（模糊）"></a>使用like操作符（模糊）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select ename,sal from emp</span><br><span class="line">where ename like &#x27;S%&#x27;</span><br><span class="line">-- 显示首字母为S的员工姓名、薪水</span><br><span class="line">select ename,sal from emp</span><br><span class="line">where ename like &#x27;__O%&#x27;</span><br><span class="line">-- 显示第三个字符为O的所有员工的姓名和工资</span><br><span class="line">select * from emp</span><br><span class="line">where mgr is null;</span><br><span class="line"></span><br><span class="line">desc emp;</span><br><span class="line">-- 查询表结构</span><br></pre></td></tr></table></figure><h5 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from emp</span><br><span class="line">order by sal ASC|DESC ,deptno asc</span><br></pre></td></tr></table></figure><h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * form emp</span><br><span class="line">limit i,n; </span><br><span class="line">-- i为查询结果的索引值</span><br><span class="line">-- n为查询结果返回的数量</span><br></pre></td></tr></table></figure><h4 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h4><h5 id="笛卡尔集"><a href="#笛卡尔集" class="headerlink" title="笛卡尔集"></a>笛卡尔集</h5><p><img src="/pic/Mysql/4.png" alt="4"></p><p>多表查询的条件不能少于表的个数-1，否则会出现笛卡尔集</p><p>当需要指定某个表的列时，需要用 表名&#x3D;&#x3D;.&#x3D;&#x3D;列名</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h3><p><img src="/pic/Mysql/5.png" alt="5"></p><h4 id="charset-str"><a href="#charset-str" class="headerlink" title="charset(str)"></a>charset(str)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select charset(ename) from emo;-- 返回字串字符集</span><br></pre></td></tr></table></figure><h4 id="concat-string2-…"><a href="#concat-string2-…" class="headerlink" title="concat (string2 [,…])"></a>concat (string2 [,…])</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(enmae,&#x27;工作是&#x27;,job) from emp;-- 连接字串，将多个列拼一列</span><br></pre></td></tr></table></figure><h4 id="instr-string-substring"><a href="#instr-string-substring" class="headerlink" title="instr(string,substring)"></a>instr(string,substring)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select instr(&#x27;hanshunping&#x27;,&#x27;ping&#x27;) from dual; -- dual 是一个亚元表，系统表可以作测试表用</span><br><span class="line">-- 返回substring在string中位置，没有返回0</span><br></pre></td></tr></table></figure><h4 id="ucase-string2"><a href="#ucase-string2" class="headerlink" title="ucase(string2)"></a>ucase(string2)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ucase(ename) from emp;-- 转化为大写</span><br></pre></td></tr></table></figure><h4 id="lcase-string2"><a href="#lcase-string2" class="headerlink" title="lcase(string2)"></a>lcase(string2)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select lcase(ename) from emp;-- 转化为小写</span><br></pre></td></tr></table></figure><h4 id="left（string2，length）"><a href="#left（string2，length）" class="headerlink" title="left（string2，length）"></a>left（string2，length）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select left(name,2) from emp; -- left可改为right改为从右取</span><br><span class="line">-- 从string2中的左边去length个字符</span><br></pre></td></tr></table></figure><h4 id="length（string）"><a href="#length（string）" class="headerlink" title="length（string）"></a>length（string）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select length(&#x27;王文豪&#x27;) from emp; -- 结果为9，utf-8一个汉字占3个字节</span><br><span class="line">-- string长度[按照字节]</span><br></pre></td></tr></table></figure><h4 id="replace-str-search-str-replace-str"><a href="#replace-str-search-str-replace-str" class="headerlink" title="replace(str,search_str,replace_str)"></a>replace(str,search_str,replace_str)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ename,replace(job,&#x27;nanager&#x27;,&#x27;经理&#x27;) from emp;</span><br><span class="line">-- 将search_str替换为replace_str</span><br></pre></td></tr></table></figure><h4 id="strcmp-str1-str2"><a href="#strcmp-str1-str2" class="headerlink" title="strcmp(str1,str2)"></a>strcmp(str1,str2)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select strcmp (&#x27;aa&#x27;,&#x27;bb&#x27;) from dual;</span><br><span class="line">-- 逐个字符比较两字串大小</span><br></pre></td></tr></table></figure><h4 id="substring-str-postion-length"><a href="#substring-str-postion-length" class="headerlink" title="substring(str,postion[,length])"></a>substring(str,postion[,length])</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select substring(ename,1,2) from emp;</span><br><span class="line">-- 从str的position位置开始取length个字符，从1开始取</span><br></pre></td></tr></table></figure><h4 id="ltrim-string2-rtrim-string2-trim-string2"><a href="#ltrim-string2-rtrim-string2-trim-string2" class="headerlink" title="ltrim(string2) rtrim(string2) trim(string2)"></a>ltrim(string2) rtrim(string2) trim(string2)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select ltrim(&quot;   文豪野犬&quot;)from dual;</span><br><span class="line">-- 去除左空格</span><br><span class="line">select rtrim(&quot;文豪野犬    &quot;)from dual;</span><br><span class="line">-- 去除右边空格</span><br><span class="line">select trim(&quot;   文豪野犬     &quot;)from dual;</span><br><span class="line">-- 去除两边空格</span><br></pre></td></tr></table></figure><h3 id="数学相关函数"><a href="#数学相关函数" class="headerlink" title="数学相关函数"></a>数学相关函数</h3><h4 id="abs-num-绝对值"><a href="#abs-num-绝对值" class="headerlink" title="abs(num)绝对值"></a>abs(num)绝对值</h4><h4 id="bin-decimal-number-十进制转二进制"><a href="#bin-decimal-number-十进制转二进制" class="headerlink" title="bin(decimal_number)十进制转二进制"></a>bin(decimal_number)十进制转二进制</h4><h4 id="ceiling-number2-向上取整，得到比num2小的最大整数"><a href="#ceiling-number2-向上取整，得到比num2小的最大整数" class="headerlink" title="ceiling(number2) 向上取整，得到比num2小的最大整数"></a>ceiling(number2) 向上取整，得到比num2小的最大整数</h4><h4 id="conv（number2-from-base-to-base-进制转化"><a href="#conv（number2-from-base-to-base-进制转化" class="headerlink" title="conv（number2,from_base,to_base) 进制转化"></a>conv（number2,from_base,to_base) 进制转化</h4><h4 id="floor-number2-向下去整，得到比num2小的最大整数"><a href="#floor-number2-向下去整，得到比num2小的最大整数" class="headerlink" title="floor(number2)向下去整，得到比num2小的最大整数"></a>floor(number2)向下去整，得到比num2小的最大整数</h4><h4 id="format（number，decimal-places-保留小数点位数（四舍五入）"><a href="#format（number，decimal-places-保留小数点位数（四舍五入）" class="headerlink" title="format（number，decimal_places)保留小数点位数（四舍五入）"></a>format（number，decimal_places)保留小数点位数（四舍五入）</h4><h4 id="hex-decimal-number-转十六进制"><a href="#hex-decimal-number-转十六进制" class="headerlink" title="hex(decimal_number)转十六进制"></a>hex(decimal_number)转十六进制</h4><h4 id="least（number，number2-…-求最小值"><a href="#least（number，number2-…-求最小值" class="headerlink" title="least（number，number2[,…]) 求最小值"></a>least（number，number2[,…]) 求最小值</h4><h4 id="mod-numbertor-denominator-取余"><a href="#mod-numbertor-denominator-取余" class="headerlink" title="mod(numbertor,denominator) 取余"></a>mod(numbertor,denominator) 取余</h4><h4 id="rand-返回随机数，范围是0-lt-x3D-v-lt-x3D-1-0"><a href="#rand-返回随机数，范围是0-lt-x3D-v-lt-x3D-1-0" class="headerlink" title="rand()返回随机数，范围是0&lt;&#x3D;v&lt;&#x3D;1.0"></a>rand()返回随机数，范围是0&lt;&#x3D;v&lt;&#x3D;1.0</h4><ol><li>如果使用rand（）每次返回不同范围随机数范围为0~1.0</li><li>如果使用rand（seed），也返回随机数，但该seed对应的随机数固定</li></ol><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><h4 id="current-date-当前日期"><a href="#current-date-当前日期" class="headerlink" title="current_date()当前日期"></a>current_date()当前日期</h4><h4 id="current-time-当前时间"><a href="#current-time-当前时间" class="headerlink" title="current_time()当前时间"></a>current_time()当前时间</h4><h4 id="current-timestamp-当前时间戳"><a href="#current-timestamp-当前时间戳" class="headerlink" title="current_timestamp()当前时间戳"></a>current_timestamp()当前时间戳</h4><h4 id="date-datetime-返回datetime的日期部分"><a href="#date-datetime-返回datetime的日期部分" class="headerlink" title="date(datetime)返回datetime的日期部分"></a>date(datetime)返回datetime的日期部分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,content,DATE(send_time) from mes;</span><br></pre></td></tr></table></figure><h4 id="date-add-date2-interval-d-value-d-type-在date中加上日期或者时间"><a href="#date-add-date2-interval-d-value-d-type-在date中加上日期或者时间" class="headerlink" title="date_add(date2,interval d_value d_type)在date中加上日期或者时间"></a>date_add(date2,interval d_value d_type)在date中加上日期或者时间</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from mes</span><br><span class="line">where date_add(send_time, interval 10 minute) &gt;= now</span><br></pre></td></tr></table></figure><h4 id="date-sub-date2-interval-d-value-d-type-在date2上减去一个时间"><a href="#date-sub-date2-interval-d-value-d-type-在date2上减去一个时间" class="headerlink" title="date_sub(date2,interval d_value d_type)在date2上减去一个时间"></a>date_sub(date2,interval d_value d_type)在date2上减去一个时间</h4><h4 id="datediff（date1，date2-两个日期差，结果为天"><a href="#datediff（date1，date2-两个日期差，结果为天" class="headerlink" title="datediff（date1，date2)两个日期差，结果为天"></a>datediff（date1，date2)两个日期差，结果为天</h4><h4 id="now-当前时间"><a href="#now-当前时间" class="headerlink" title="now()当前时间"></a>now()当前时间</h4><h4 id="year-month-day-date-datetime"><a href="#year-month-day-date-datetime" class="headerlink" title="year|month|day date(datetime)"></a>year|month|day date(datetime)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select year(now()) from dual;</span><br></pre></td></tr></table></figure><h4 id="unix-timestamp-返回1970-1-1到现在的秒数"><a href="#unix-timestamp-返回1970-1-1到现在的秒数" class="headerlink" title="unix_timestamp()返回1970-1-1到现在的秒数"></a>unix_timestamp()返回1970-1-1到现在的秒数</h4><h4 id="from-unixtime-可以把一个unix-timestamp可以把一个unix-timestamp秒数，转成指定格式的日期"><a href="#from-unixtime-可以把一个unix-timestamp可以把一个unix-timestamp秒数，转成指定格式的日期" class="headerlink" title="from_unixtime()可以把一个unix_timestamp可以把一个unix_timestamp秒数，转成指定格式的日期"></a>from_unixtime()可以把一个unix_timestamp可以把一个unix_timestamp秒数，转成指定格式的日期</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select from_unixtime(1618483484,&#x27;%￥-%m-%d %H:%i:%s&#x27;) from dual;</span><br><span class="line">-- %￥-%m-%d 格式是规定好的，表示年月日 %H:%i:%s表示时分秒</span><br><span class="line">-- 在实际开发中，常用int来保存一个unix时间戳，然后使用from_unixtime()进行转化</span><br></pre></td></tr></table></figure><h3 id="加密和系统函数"><a href="#加密和系统函数" class="headerlink" title="加密和系统函数"></a>加密和系统函数</h3><h4 id="user"><a href="#user" class="headerlink" title="user()"></a>user()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select user() from dual; </span><br><span class="line">-- 用户@IP地址</span><br><span class="line">-- 可以查看登录到mysql的有哪些用户，以及登录的ip</span><br></pre></td></tr></table></figure><h4 id="datebase"><a href="#datebase" class="headerlink" title="datebase()"></a>datebase()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select datebase()[from dual]; -- 查询当前使用数据库</span><br></pre></td></tr></table></figure><h4 id="md5-str"><a href="#md5-str" class="headerlink" title="md5(str)"></a>md5(str)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select MD5(&#x27;wwh&#x27;) from dual;</span><br><span class="line">-- 为字符串算出一个MD5 32的字符串，常用（用户密码）加密,数据库中存放的是加密后的密码</span><br></pre></td></tr></table></figure><h4 id="password-str"><a href="#password-str" class="headerlink" title="password(str)"></a>password(str)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select password(&#x27;wwh&#x27;) from dual;</span><br><span class="line">-- 加密函数，MySQL数据库的用户密码就是password函数加密</span><br></pre></td></tr></table></figure><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><h4 id="if-expr1-expr2-expr3"><a href="#if-expr1-expr2-expr3" class="headerlink" title="if(expr1,expr2,expr3)"></a>if(expr1,expr2,expr3)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select if(expr1,expr2,expr3) from dual;</span><br><span class="line">-- 如果expr1为true，则返回expr2，否则返回expr3</span><br></pre></td></tr></table></figure><h4 id="ifnull-expr1-expr2"><a href="#ifnull-expr1-expr2" class="headerlink" title="ifnull(expr1,expr2)"></a>ifnull(expr1,expr2)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ifnull(expr1,expr2) from dual;</span><br><span class="line">-- 如果expr1不为null，则返回expr1，否则返回expr2</span><br></pre></td></tr></table></figure><h4 id="多重分支"><a href="#多重分支" class="headerlink" title="多重分支"></a>多重分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select case</span><br><span class="line">when true then &#x27;jack&#x27;</span><br><span class="line">when false then &#x27;tom&#x27;</span><br><span class="line">else &#x27;marry&#x27; end</span><br></pre></td></tr></table></figure><h2 id="表类型和存世引擎"><a href="#表类型和存世引擎" class="headerlink" title="表类型和存世引擎"></a>表类型和存世引擎</h2><blockquote><p>查看所有的存储引擎</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><p><img src="/pic/Mysql/6.png" alt="6"></p><p>三种常用的存储引擎</p><blockquote><p>inndb 存储引擎</p></blockquote><p>1.支持事务，2.支持外键 3.支持行级锁</p><blockquote><p>myisam</p></blockquote><p>1.添加速度快 2. 不支持外键和事务 3.支持表级锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table t27(</span><br><span class="line">id int,</span><br><span class="line">`name` varchar(32)) engine myisam</span><br></pre></td></tr></table></figure><blockquote><p>memory</p></blockquote><p>1.数据存储在内存中 2.执行速度很慢（没有io）读写 3.默认支持索引（hash表）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table t29(</span><br><span class="line">id int,</span><br><span class="line">`name` varchar(32)) engine memory</span><br><span class="line">-- 经典用法，用户的在线状态</span><br></pre></td></tr></table></figure><blockquote><p>指令修改存储引擎</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table `t29` engine = memory;</span><br></pre></td></tr></table></figure><h2 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h2><p>视图是对应的真实表的映射</p><blockquote><p>视图的基本使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名 as select 语句;</span><br><span class="line">create view emp_view01 as select empno,ename,job from emp;</span><br><span class="line">-- 创建视图</span><br><span class="line">alter view viewname as select 语句</span><br><span class="line">-- 更改视图</span><br><span class="line">show create view viewname;</span><br><span class="line">-- 显示视图</span><br><span class="line">drop view name1,view2;</span><br><span class="line">-- 删除视图</span><br></pre></td></tr></table></figure><blockquote><p>视图的细节</p></blockquote><ol><li>创建视图后，到数据库去看，对应的视图只有一个视图结构文件（形式：视图名.frm）</li><li>视图的数据变化会影响到基表，基表的数据变化也会影响视图</li></ol><p>&#x3D;&#x3D;总结&#x3D;&#x3D;</p><p>1.视图时根据基表（可以时多个基表）来创建的， 视图时虚拟的表</p><p>2.视图也有列，数据来自基表</p><p>3.通过视图可以修改基表的数据</p><p>4.基表的该表，也会英雄到视图的数据</p><p><img src="/pic/Mysql/7.png" alt="7"></p><h2 id="mysql用户管理"><a href="#mysql用户管理" class="headerlink" title="mysql用户管理"></a>mysql用户管理</h2><p>可以根据不同的开发人员，付给相应的mysql权限</p><blockquote><p>创建用户</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create user `用户名`@`允许登录位置` identified by `密码`</span><br><span class="line">-- `允许登录位置` 指的是 登录的ip</span><br></pre></td></tr></table></figure><blockquote><p>删除用户</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user `用户名`@`允许登录位置`</span><br></pre></td></tr></table></figure><blockquote><p>给用户授权</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 基本语法</span><br><span class="line">grant 权限列表 on 库.对象 to &#x27;用户名&#x27;@&#x27;登录位置&#x27; [identified by &#x27;密码&#x27;]</span><br></pre></td></tr></table></figure><blockquote><p>回收用户授权</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 基本语法</span><br><span class="line">revoke 权限列表 on 库.对象名 from &#x27;用户名&#x27;@&#x27;登录位置&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>用户管理的细节</p></blockquote><ol><li>在创建用户是如果不指定host，则为%，%表示所有ip都有连接权限</li><li>也可以这样指定</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;xxx&#x27;@&#x27;192.168.1.%&#x27;</span><br><span class="line">-- 表示xxx用户在192.168.1.*的ip可以登录</span><br></pre></td></tr></table></figure><ol start="3"><li>在删除用户的时候，如果host不是%,需要明确指定 ‘用户‘@’host值’</li></ol><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>步骤：</p><ol><li>加载驱动</li><li>连接数据库 DriverManager</li><li>获得执行sql的对象 Statement</li><li>获得返回的结果集</li><li>释放连接</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;h2 id=&quot;1、初始MySQL&quot;&gt;&lt;a href=&quot;#1、初始MySQL&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Database" scheme="https://nihility500.github.io/categories/Database/"/>
    
    
    <category term="MySql" scheme="https://nihility500.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>java进阶</title>
    <link href="https://nihility500.github.io/2023/04/05/java%E8%BF%9B%E9%98%B6/"/>
    <id>https://nihility500.github.io/2023/04/05/java%E8%BF%9B%E9%98%B6/</id>
    <published>2023-04-05T06:52:00.000Z</published>
    <updated>2023-04-05T07:24:00.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO流专题"><a href="#IO流专题" class="headerlink" title="IO流专题"></a>IO流专题</h1><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>方法1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String pathname)</span><br></pre></td></tr></table></figure><p><img src="/pic/java%E8%BF%9B%E9%98%B6/1.png" alt="1"></p><p>方法2.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(File parent,String child)<span class="comment">//根据父目录文件+子路径构建   </span></span><br></pre></td></tr></table></figure><p><img src="/pic/java%E8%BF%9B%E9%98%B6/2.png" alt="2"></p><h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><p>getName，文件名字</p><p>getAbsolutePath,文件绝对路径</p><p>getParent,文件父级目录</p><p>length,文件大小（字节）</p><p>exists,文件是否存在</p><p>isFile,是否是一个文件</p><p>isDirectory是不是一个目录</p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>创建目录（mkdir是单极目录，mkdirs是多级目录）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\demo\\a\\b\\c&quot;</span>);</span><br><span class="line">file.mkdirs()</span><br></pre></td></tr></table></figure><p>创建文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File sub=<span class="keyword">new</span> <span class="title class_">File</span>(file,<span class="string">&quot;news.txt&quot;</span>);</span><br><span class="line">sub.createNewFile</span><br></pre></td></tr></table></figure><p>删除</p><p>file.delete();</p><h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><p><strong>流的分类</strong>：</p><ul><li>按操作数据单位不同为：字节流（8bit）–》图片，字符流（按字符）–》文本文件</li><li>按数据流向不同分为：输入流，输出流</li><li>按角色不同分为：节点流，处理流&#x2F;包装流</li></ul><p><img src="/pic/java%E8%BF%9B%E9%98%B6/3.png" alt="3"></p><p>上面四类均为抽象类，不能new抽象类，只能靠子类去实现</p><h2 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h2><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>字节输入流：</p><p><img src="/pic/java%E8%BF%9B%E9%98%B6/4.png" alt="4"></p><p>该种仅能一次读一个字节</p><p>可通过byte[] buf&#x3D; new byte[8];（最多8个字节）</p><h3 id="FileOutoutStream"><a href="#FileOutoutStream" class="headerlink" title="FileOutoutStream"></a>FileOutoutStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入字节</span></span><br><span class="line">fileOutputStream.write(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line"><span class="comment">//写入一个字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span><span class="string">&quot;Hello,world&quot;</span>;</span><br><span class="line"><span class="comment">//str.getBytes()可以把字符串---&gt;字节数组</span></span><br><span class="line">fileOutputStream.write(str,getBytes());</span><br><span class="line"><span class="comment">//write(byte[] b,int off, int len)将len字节从位于偏移量off的指定字节数组</span></span><br><span class="line">fileOutputStream.write(str.getBytes(),<span class="number">0</span>,str.length());</span><br><span class="line"><span class="comment">//后两个，第一个是从某个量开始，第二个是填充几个</span></span><br></pre></td></tr></table></figure><ol><li>new FileOutpputStream(filePath)；创建方式，当写入内容时，会覆盖原内容</li><li>new FileOutpputStream(filePath true)；</li></ol><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>将字节流转换为字符流</p><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>将字节流FileInputStream转成字符流InputStreamReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span><span class="string">&quot;路径&quot;</span>;</span><br><span class="line"><span class="comment">//1.把FileInputStream转成InputStreamReader</span></span><br><span class="line"><span class="comment">//2.指定编码gbk</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">//3.把InputStreamReader传入BufferedReader</span></span><br><span class="line">BufferedReader br= <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(usr);</span><br><span class="line"><span class="comment">//4.读取</span></span><br><span class="line">String s=br.readLine();</span><br><span class="line">System.out.println(<span class="string">&quot;读取内容=&quot;</span>+s);</span><br><span class="line"><span class="comment">//5.关闭外层流</span></span><br><span class="line">br.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OutputStreamReader"><a href="#OutputStreamReader" class="headerlink" title="OutputStreamReader"></a>OutputStreamReader</h3><p>把FileOutputStream字节流转成字符流OutputStreamWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span><span class="string">&quot;路径&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">charSet</span> <span class="operator">=</span><span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line">OutputStreamWrinter osw= <span class="keyword">new</span> <span class="title class_">OutputStreamWrinter</span>(<span class="keyword">new</span> <span class="title class_">fileOutputStream</span>(filePath),charSet<span class="string">&quot;);</span></span><br><span class="line"><span class="string">osw.write(&quot;</span>hi，菅田将暉<span class="string">&quot;);</span></span><br><span class="line"><span class="string">osw.close();</span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>按照<span class="string">&quot;+charSet+&quot;</span>保存文件成功<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>使用输入流将文件从磁盘输入到内存，然后使用输出流将内存中的文件输出到磁盘中即可</p><h2 id="文件字符流说明"><a href="#文件字符流说明" class="headerlink" title="文件字符流说明"></a>文件字符流说明</h2><p><img src="/pic/java%E8%BF%9B%E9%98%B6/5.png" alt="5"></p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>输出文件的字符</p><ol><li>创建FileReader对象</li><li>循环读取，使用read(buf)；</li><li>读取单个字符时用sout ((char)date);读取字符串时用sout(buf,0,readLength)</li></ol><p>其实大体上和之前类似</p><h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><ol><li>创建FileWriter对象</li><li>fileWriter.write();</li></ol><h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><ol><li><p>节点流可以从一个特点的数据源读写数据，</p><p>直接处理数据源，如FileReader、FileWriter</p></li><li><p>处理流（也叫包装流）是”连接“在已存在的流（节点流和处理流）之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter</p><p>BufferedReader类中，有属性Reader，即可以封装一个节点流，只要节点流是reader的子类</p><p><u></u><img src="/pic/java%E8%BF%9B%E9%98%B6/6.png" alt="6"></p></li></ol><p><strong>修饰器设计模式</strong></p><h2 id="处理流设计模式"><a href="#处理流设计模式" class="headerlink" title="处理流设计模式"></a>处理流设计模式</h2><h2 id="打印流（本质就是输出流）"><a href="#打印流（本质就是输出流）" class="headerlink" title="打印流（本质就是输出流）"></a>打印流（本质就是输出流）</h2><p>PrintStream和PrintWriter</p><p>打印流只有输出流，没有输入流</p><h3 id="PrintStream-字节打印流"><a href="#PrintStream-字节打印流" class="headerlink" title="PrintStream 字节打印流"></a>PrintStream 字节打印流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">out.close();</span><br><span class="line"><span class="comment">//默认情况下，PrintStream输出数据的位置是 标准输出，即显示器</span></span><br><span class="line"><span class="comment">//因为print在底层的方法是wirte，所以可以直接调用write进行打印、输出</span></span><br><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br><span class="line"><span class="comment">//修改文件创建路径</span></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//输出结果会保存在文件内</span></span><br></pre></td></tr></table></figure><h3 id="PrintWriter字符打印流"><a href="#PrintWriter字符打印流" class="headerlink" title="PrintWriter字符打印流"></a>PrintWriter字符打印流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;路径&quot;</span>);</span><br><span class="line">pw.print(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="配置文件Properties"><a href="#配置文件Properties" class="headerlink" title="配置文件Properties"></a>配置文件Properties</h2><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><ol><li><p>创建Properties对象</p></li><li><p>加载指定配置文件</p><p>.load</p></li><li><p>把k-v显示控制台</p><p>.list</p></li><li><p>根据key获得对应值</p></li></ol><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建properties对象</span></span><br><span class="line">Properities propeities=<span class="keyword">new</span> <span class="title class_">Properites</span>();</span><br><span class="line"><span class="comment">//2.使用创建方法</span></span><br><span class="line">properties.setProperties(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//将k-v 存储在文件中</span></span><br><span class="line">properties.store=(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;存放路径&quot;</span>),<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h2><ol><li>需要在结束关闭文件流，释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure><ol start="2"><li><p>当文档读取完后.read&#x3D;-1</p></li><li><p>FileWriter使用后，必须要关闭（close）或者刷新（flush），否则写入不到指定的文件</p></li><li><p>这里的fileInputStream 只是一个对象，没有new之前它是为空的，假如程序没有执行try ，直接关闭空对象会有<a href="https://so.csdn.net/so/search?q=%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8&spm=1001.2101.3001.7020">空指针异常</a>，当一个对象被创建的时候，就已经有了地址，他就不可能为空，所以这里只是做个判断，它没有被创建就关闭时出现的异常！</p></li><li><pre><code class="java">String name =properties.get(&quot;name&quot;)+&quot;&quot;;//object---&gt;String<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. ```java</span><br><span class="line">   Object age =Integer.parseInt(properties.get(&quot;age&quot;)+&quot;&quot;);//String---&gt;Obje</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>类的序列化由实现java.io.Serializable接口的类启用。</strong>  不实现此接口的类将不会使任何状态序列化或反序列化。 可序列化类的所有子类型都是可序列化的。  序列化接口没有方法或字段，仅用于标识可串行化的语义。</p></li></ol><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><ul><li>线程是独立的执行路径</li><li>再程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程；</li><li>再一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器时与操作系统紧密相关的，先后顺序时不能人为干预的</li><li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；</li><li>线程会带来额外开销，如cpu调度时间，并发控制开销</li><li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li></ul><h2 id="线程的创造"><a href="#线程的创造" class="headerlink" title="线程的创造"></a>线程的创造</h2><h3 id="三种创建方式"><a href="#三种创建方式" class="headerlink" title="三种创建方式"></a>三种创建方式</h3><p>Thread class—-》继承thread类</p><p>Runnable接口—–》实现Runable接口</p><p>Callable接口—–》实现Callable接口</p><p><img src="/pic/java%E8%BF%9B%E9%98%B6/7.png" alt="7"></p><p>三种线程在main的创建方式</p><h4 id="1-Thread类"><a href="#1-Thread类" class="headerlink" title="1.Thread类"></a>1.Thread类</h4><ul><li>自定义线程继承Thread类</li><li>run（）</li><li>sart（）</li><li>不建议使用：避免OOP单继承局限性</li></ul><h5 id="e-g-案例下载"><a href="#e-g-案例下载" class="headerlink" title="e.g.案例下载"></a>e.g.案例下载</h5><p>下载包，添加库，使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtils.copyURLToFile(<span class="keyword">new</span> <span class="title class_">URL</span>(url),<span class="keyword">new</span> <span class="title class_">File</span>(name));</span><br></pre></td></tr></table></figure><h4 id="2-Runnable接口"><a href="#2-Runnable接口" class="headerlink" title="2.Runnable接口"></a>2.Runnable接口</h4><ul><li>实现runnable接口具有多线程能力</li><li>启动线程：传入目标对象+Thread对象.start()</li><li>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</li></ul><h4 id="3-Callable接口"><a href="#3-Callable接口" class="headerlink" title="3.Callable接口"></a>3.Callable接口</h4><ol><li>实现callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建按目标对象</li><li>创建执行服务：ExecutorService ser &#x3D;Executor.newFixedThreadPool(1);</li><li>提交执行:Future<Bollean>result1&#x3D;ser.submit(t1);</li><li>获取结果：boolean r1 &#x3D;result1.get(1)</li><li>关闭服务：ser.shutdownNow();</li></ol><h2 id="静态代理-仍需理解"><a href="#静态代理-仍需理解" class="headerlink" title="静态代理(仍需理解)"></a>静态代理(仍需理解)</h2><p>代理这个词是来源于Java设计模式设计模式&amp;spm&#x3D;1001.2101.3001.7020)中的<strong>代理模式</strong>，代理模式最简单的理解就是通过<strong>第三方</strong>来代理我们的工作</p><ol><li>创建一个主题接口</li><li>创建该接口的实现类，用来实现功能（也被叫做代理类）</li><li>创建实现类的代理类（两个类需要<strong>实现共同的主题接口</strong>，这样才能对原有功能进行增强），使用代理类对原有类进行包装</li></ol><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul><li><p>函数式接口的定义：</p></li><li><ul><li>任何接口，如果只包含一个抽象方法，那么它就是一个函数式接口</li><li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;多线程学习.....&quot;</span>)).start</span><br></pre></td></tr></table></figure><h2 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h2><p>设置一个标识体，作为判断条件</p><h2 id="线程休眠-sleep"><a href="#线程休眠-sleep" class="headerlink" title="线程休眠_sleep"></a>线程休眠_sleep</h2><p>sleep（时间<code>单位为毫秒 </code>）指定当前线程阻塞的毫秒数</p><p>sleep存在异常InterruuptedException</p><p>sleep可模拟网络延时，倒计时等</p><p><em>（不理解）</em> <strong>每个队形都有一个锁，sleep不会释放锁</strong></p><h2 id="线程礼让-yield"><a href="#线程礼让-yield" class="headerlink" title="线程礼让_yield"></a>线程礼让_yield</h2><p>当前线程<strong>暂停</strong>，线程重新竞争，可能仍继续执行，也可能礼让成功，其他线程执行</p><h2 id="线程强行执行-join"><a href="#线程强行执行-join" class="headerlink" title="线程强行执行_join"></a>线程强行执行_join</h2><p>插队，一直执行到全部结束，才开始其他线程</p><h2 id="观察线程状态"><a href="#观察线程状态" class="headerlink" title="观察线程状态"></a>观察线程状态</h2><h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="-线程的几种状态"></a>-线程的几种状态</h3><ol><li>新建状态（new）</li><li>就绪状态（Runnable）</li><li>运行状态（Running）</li><li>阻塞状态（Blocked）</li><li>死亡状态（Dead）—&gt;一旦进入死亡状态，无法再启动</li><li>等待某一线程执行特定动作（Waiting）</li><li>等待某一线程达到指定等待时间（Timed_Waiting)</li><li>退出状态（Termianted）</li></ol><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li><p>优先级用数字表示，范围从1-10，<strong>优先级高只是分配的资源多，不是先执行</strong></p></li><li><p>优先级用数字表示，范围为1-10</p></li><li><p>获取或改变优先级的方法(先设定优先级，在启动start())</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getPriority.setpriority(<span class="type">int</span> xxx)</span><br></pre></td></tr></table></figure><h2 id="守护-daemon-线程"><a href="#守护-daemon-线程" class="headerlink" title="守护(daemon)线程"></a>守护(daemon)线程</h2><ul><li>线程分为i用户线程和守护线程</li><li>虚拟机必须确保用户线程执行完毕—&gt;main()是用户线程</li><li>虚拟机不用等待守护线程执行完毕—&gt;gc()垃圾回收线程</li><li>如，后台记录操作日志，监控内存，垃圾回收等待</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>(god);</span><br><span class="line">thread.setDaemon(<span class="literal">true</span>);<span class="comment">//默认为false，即用户线程，true为保护线程</span></span><br></pre></td></tr></table></figure><h2 id="线程同步机制（synchronizied既有代码块锁又有方法锁）"><a href="#线程同步机制（synchronizied既有代码块锁又有方法锁）" class="headerlink" title="线程同步机制（synchronizied既有代码块锁又有方法锁）"></a>线程同步机制<em>（synchronizied既有代码块锁又有方法锁）</em></h2><h3 id="并发"><a href="#并发" class="headerlink" title="-并发"></a>-并发</h3><ul><li>同一对象，同时被多个线程操作.</li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="-线程同步"></a>-线程同步</h3><p>处理并发问题，并且某些线程还想修改对象，就需要线程同步。线程同步就是一种等待机制，多个徐奥同时访问此对象的相册进入这个<strong>对象的等待池</strong>形成队列</p><h3 id="队列和锁"><a href="#队列和锁" class="headerlink" title="-队列和锁"></a>-队列和锁</h3><p>线程同步的形成条件：队列＋锁</p><p><font color='red'><strong>锁机制synchronized</strong></font></p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="-同步方法"></a>-同步方法</h3><ul><li>同步对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>method代指方法，args代指引用变量</p><ul><li>同步块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronizied(Obj)&#123;&#125;</span><br></pre></td></tr></table></figure><p>Obj称之为<strong>同步监视器</strong>，Obj可以是任何对象，但是推荐使用共享资源</p><p>缺陷：若将一个大方法申明为synchronizied将会影响效率</p><p><strong>注：</strong>注意锁的对象</p><h3 id="JUC安全类型的集合"><a href="#JUC安全类型的集合" class="headerlink" title="-JUC安全类型的集合"></a>-JUC安全类型的集合</h3><p><img src="/pic/java%E8%BF%9B%E9%98%B6/8.png" alt="8"></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="-死锁"></a>-死锁</h3><p>多个线程中的某两个或多个对象分别拥有对方需要执行的锁，这时候双方都无法执行，发生“死锁”问题</p><p>某一个对象同时又有两个以上对象的锁，就有可能发生死锁问题</p><ul><li><p>产生死锁的四个必要条件：</p><p>1.互斥条件：一个资源每次只能被一个进程使用</p><pre><code>    2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不妨    2. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺    2. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</code></pre></li></ul><h2 id="Lock锁（仅有代码块锁）"><a href="#Lock锁（仅有代码块锁）" class="headerlink" title="Lock锁（仅有代码块锁）"></a>Lock锁<em>（仅有代码块锁）</em></h2><p>Java.util.concurrent.locks.Lock接口   </p><p>(可重入锁)ReentrantLock类实现了Lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//保证线程安全的代码</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">       lock.unlock();<span class="comment">//解锁、 </span></span><br><span class="line">    &#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>消费者需要根据生产者生产的产品有无来消费，生产者也要根据消费者消费后产品是否剩余继续生产</p><h3 id="管程法（有点难，建议多看两遍狂神例子）"><a href="#管程法（有点难，建议多看两遍狂神例子）" class="headerlink" title="-管程法（有点难，建议多看两遍狂神例子）"></a>-管程法（有点难，建议多看两遍狂神例子）</h3><p>在生产者和消费者间创建一个缓冲区，将产品放置在缓冲区，两者再根据缓冲区的数据操作</p><p><em>封装，面向对象</em>需要掌握牢固</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>提前创造好多个线程，放入线程池中，使用时直接获取，使用后放回池中，可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。</p><p><strong>好处：</strong></p><ul><li>提高响应速度</li><li>降低资源消耗</li><li>便于线程管理</li></ul><p>​      –corePoolSize：核心池的大小</p><p>​      –maximumPoolSize：最大线程数</p><p>​      –keepAliveTime：线程没有任务是最多保持多长时间后会终止</p><p>1.创建线程池</p><p><img src="/pic/java%E8%BF%9B%E9%98%B6/9.png" alt="9"></p><p>2.service.shutdown();</p><h2 id="PS"><a href="#PS" class="headerlink" title="PS."></a>PS.</h2><ol><li>调用start（）方法开启线程与调用run（）</li></ol><p><img src="/pic/java%E8%BF%9B%E9%98%B6/10.png" alt="10"></p><ol start="2"><li><p>线程开启不一定立即执行，由cpu安排调度</p></li><li><p>多线程操作同一个资源的情况下，线程不安全，数据紊乱</p></li><li><p>获取当前线程的名字：Thread.currentThread().getName()</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IO流专题&quot;&gt;&lt;a href=&quot;#IO流专题&quot; class=&quot;headerlink&quot; title=&quot;IO流专题&quot;&gt;&lt;/a&gt;IO流专题&lt;/h1&gt;&lt;h2 id=&quot;创建文件&quot;&gt;&lt;a href=&quot;#创建文件&quot; class=&quot;headerlink&quot; title=&quot;创建文件&quot;</summary>
      
    
    
    
    <category term="Java与开发" scheme="https://nihility500.github.io/categories/Java%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="java" scheme="https://nihility500.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础</title>
    <link href="https://nihility500.github.io/2023/04/05/java%E5%9F%BA%E7%A1%80/"/>
    <id>https://nihility500.github.io/2023/04/05/java%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-05T01:26:48.000Z</published>
    <updated>2023-04-05T06:09:04.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h1><h2 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h2><p>方法是语句的集合，他们在一起执行一个功能</p><ul><li><p>方法是解决一类问题的步骤的有序组合</p></li><li><p>方法包含于类或对象中</p></li><li><p>方法在程序中被创建，在其他地方被引用</p></li></ul><p>设计方法的原则:一个方法仅实现一个功能</p><h2 id="2-方法的定义及调用"><a href="#2-方法的定义及调用" class="headerlink" title="2.方法的定义及调用"></a>2.方法的定义及调用</h2><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>java的方法类似与其他语言的函数，是一段<strong>用来完成特定功能的代码片段</strong>，一般情况下，定义一个方法包含以下语法:</p><p><strong>方法的名字可以相同，但是参数列表必须不同</strong></p><p><strong>方法包含一个方法头和一个方法体</strong>。</p><p>方法所有部分:</p><ul><li><p><strong>修饰符</strong>:是可选的，靠苏编译器如何调用该方法。定义了该忘发的<strong>访问类型</strong>.</p></li><li><p><strong>返回值类型</strong>：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。这种情况下，returnValueType是关键字void。</p></li><li><p><strong>方法名</strong>：是方法的实际名称。方法名和参数表共同构成方法签名。</p></li><li><p><strong>参数类型</strong>:参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型，顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</p></li><li><ul><li><p>形式参数:在方法被调用时用于接收外界输入数据，起定义的作用。</p></li><li><p>实参:调用方法时实际传给方法的数据。</p></li></ul></li><li><p><strong>方法体</strong>：方法体包含具体的语句，定义该方法的功能。</p></li></ul><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul><li><p>调用方法：对象名.方法名</p></li><li><p>非静态方法无法在其他地方直接引用</p></li><li><p>静态方法可直接引用</p></li></ul><h2 id="3-方法重载"><a href="#3-方法重载" class="headerlink" title="3.方法重载"></a>3.方法重载</h2><p>重载就是在一个类中，有相同的函数名称，单形参不同的函数</p><p>方法重载的规则:</p><ul><li>方法名称必须相同</li><li>参数列表必须不同（个数，类型，参数排列顺序不同）</li><li>方法的返回类型可以相同也可以不同</li><li>仅仅返回类型不同不足以成为方法的重载</li></ul><h2 id="4-命令行传参"><a href="#4-命令行传参" class="headerlink" title="4.命令行传参"></a><em>4.命令行传参</em></h2><h2 id="5-可变参数"><a href="#5-可变参数" class="headerlink" title="5.可变参数"></a>5.可变参数</h2><p><strong>一个方法中只能指定一个可变参数，他必须是 方法的最后一个参数。任何普通的参数必须在他之前声明。</strong></p><h2 id="6-递归（少用，小计算可用）"><a href="#6-递归（少用，小计算可用）" class="headerlink" title="6.递归（少用，小计算可用）"></a><font  color= "red"  >6.递归</font>（少用，小计算可用）</h2><p>递归包括两部分：</p><ul><li>递归头：什么不调用自身</li><li>递归体：什么时候调用</li></ul><h1 id="java流程控制"><a href="#java流程控制" class="headerlink" title="java流程控制"></a>java流程控制</h1><h2 id="1-用户交互Scannel"><a href="#1-用户交互Scannel" class="headerlink" title="1.用户交互Scannel"></a>1.用户交互Scannel</h2><h3 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h3><p>java.util.Scanner是Java5的新特征。，<strong>我们可以通过Scanner类来获取用户的输入。</strong></p><ul><li>IO流（输入输出）不关闭会一直占用资源</li></ul><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><pre><code>1. 一定要读取到有效字符后次啊可以结束输入。2. 对输入有效字符之前遇到的空白，next()方法会自动将其去掉3. 只有输入有效字符之前才将其后面输入的空白作为分隔符或者结束符4. next()不能的到带有空格的字符串</code></pre><h2 id="nextLine"><a href="#nextLine" class="headerlink" title="nextLine()"></a>nextLine()</h2><ol><li>以Enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符</li><li>可以获得空白</li></ol><h2 id="2-顺序结构"><a href="#2-顺序结构" class="headerlink" title="2.顺序结构"></a><em>2.顺序结构</em></h2><ul><li>按顺序一句一句执行</li><li><strong>是任何一个算法都离不开的一种基本算法结构。</strong></li></ul><h2 id="3-选择结构"><a href="#3-选择结构" class="headerlink" title="3.选择结构"></a>3.选择结构</h2><ul><li><h3 id="if单选择结构"><a href="#if单选择结构" class="headerlink" title="if单选择结构"></a>if单选择结构</h3><p><em>equals：判断字符串是否相等</em></p><p>语法:if(布尔表达式){<em>&#x2F;&#x2F;如果布尔表达式为ture将执行的语句</em>}</p></li><li><h3 id="if双选择结构"><a href="#if双选择结构" class="headerlink" title="if双选择结构"></a>if双选择结构</h3><p>语法：if(布尔表达式){<em>&#x2F;&#x2F;如果布尔表达式为ture</em>}</p><p>else{<em>&#x2F;&#x2F;如果布尔表达式为false</em>}</p></li><li><h3 id="if多选择结构"><a href="#if多选择结构" class="headerlink" title="if多选择结构"></a>if多选择结构</h3><p><img src="/pic/java%E5%9F%BA%E7%A1%80/p1.png" alt="img1"></p><ul><li>if语句至多有个else语句，else语句必须在所有的else if语句之后</li><li>if语句可以有若干个else if语句，但他们碧血在else语句之前</li><li>其中一个else if语句检测为ture，其他额else if以及else 语句都将跳过执行</li></ul></li><li><h3 id="嵌套的if结构"><a href="#嵌套的if结构" class="headerlink" title="嵌套的if结构"></a>嵌套的if结构</h3><p><img src="/pic/java%E5%9F%BA%E7%A1%80/p2.png" alt="img2"></p><h2 id="switch多选规则结构"><a href="#switch多选规则结构" class="headerlink" title="switch多选规则结构"></a>switch多选规则结构</h2><ul><li><p>多选择结构还有一个实现方式就是switch case语句</p></li><li><p>switch case语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支</p><p><img src="/pic/java%E5%9F%BA%E7%A1%80/p3.png" alt="img3"></p><p><em>&#x2F;&#x2F;可选 可以不要</em></p></li></ul></li></ul><h2 id="4-循环结构"><a href="#4-循环结构" class="headerlink" title="4.循环结构"></a><em>4.循环结构</em></h2><h1 id="一-Java基础语法"><a href="#一-Java基础语法" class="headerlink" title="一.Java基础语法"></a>一.Java基础语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><em>三种注释</em></p><h3 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1.单行注释"></a>1.单行注释</h3><p>&#x2F;&#x2F; 加上注释的内容</p><h3 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2.多行注释"></a>2.多行注释</h3><p>&#x2F;*   中</p><p>间</p><p>为</p><p>注</p><p>释</p><p>内</p><p>容   </p><p>*&#x2F;</p><h3 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="3.文档注释"></a>3.文档注释</h3><p>&#x2F;**开头</p><p>*&#x2F;结尾</p><h1 id="二-标识符"><a href="#二-标识符" class="headerlink" title="二.标识符"></a>二.标识符</h1><h2 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1.关键字"></a>1.关键字</h2><p><img src="/pic/java%E5%9F%BA%E7%A1%80/p4.png" alt="img4"></p><p><strong>Java关键字不能用来做其他作用，如起名字用class</strong></p><h2 id="2-标识符注意点"><a href="#2-标识符注意点" class="headerlink" title="2.标识符注意点"></a>2.标识符注意点</h2><ul><li>所有标识符应为字母（A-Z,a-z），美元符（$），或者下划线（_），中文，开始</li><li>首字母后可以是任意字符组合</li><li>Java关键字不能用来做其他作用，如起名字用class</li><li><strong>标识符是大小写敏感的</strong></li></ul><h1 id="三-数据类型"><a href="#三-数据类型" class="headerlink" title="三.数据类型"></a>三.数据类型</h1><h2 id="1-强类型语言"><a href="#1-强类型语言" class="headerlink" title="1.强类型语言"></a>1.强类型语言</h2><p><strong>要求变量的使用要严格符合规定，所有的变量都必须先定义后才能使用</strong></p><h2 id="2-弱类型语言"><a href="#2-弱类型语言" class="headerlink" title="2.弱类型语言"></a>2.弱类型语言</h2><p><em>字符串和数字能混合计算”12”+3&#x3D;123or”123”</em></p><h2 id="3-Java的数据类型分为两大类"><a href="#3-Java的数据类型分为两大类" class="headerlink" title="3.Java的数据类型分为两大类"></a>3.Java的数据类型分为两大类</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p><img src="/pic/java%E5%9F%BA%E7%A1%80/p5.png" alt="img5"></p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p><img src="/pic/java%E5%9F%BA%E7%A1%80/6.png" alt="img6"></p><p><strong>少用浮点数进行比较</strong></p><h1 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h1><ul><li>为了更好滴组织类，Java提供了包机制没用于区别类名的命名空间</li><li>包语句的语法格式为:package pkg1[.pkg2[.pkg3…]];</li><li><strong>一般利用公司的域名倒置作为包名</strong></li><li>为了能够使用某一个包的成员，我们需要在Java程序中明确导入该报。使用”import”语句可完成此功能</li></ul><p>如：import package1[.package2…].(classname| *)</p><ul><li>*可以导入这个包下的所有类</li></ul><h1 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h1><ul><li>javadoc命令是用来生成自己API文档的</li><li>@author 作者名</li><li>@version 版本号</li><li>@since 指明需要最早使用的jdk版本</li><li>@param 参数名</li><li>@ return 返回值情况</li><li>@throws 异常抛出情况</li></ul><p><strong>命令行生成javadoc</strong></p><p>javadoc 参数 Java文件</p><p> 类型转换</p><ul><li><p>Java是强类型语言，进行有些运算时，需要用到类型转换。</p></li><li><p>运算中，不同类型需要转化为同一类型再计算。</p></li><li><p><strong>小转大自动转化，大转小强制转化。例：int i &#x3D;18;byte b &#x3D;(byte)i;</strong></p><p><img src="/pic/java%E5%9F%BA%E7%A1%80/p7.png" alt="img7"></p></li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h2><ol><li>不能对布尔值进行转换</li><li>不能吧对象类型转化为不相干的类型🌂</li><li>在把高容量转化到低容量，强制转换</li><li>转换时存在内存溢出，或者精度问题</li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><strong>局部变量</strong></p><p>必须声明和初始化，在{}内才有效</p><p><strong>实例变量</strong></p><ul><li>从属于对象；若未自行初始化，默认值为0 0.0 u0000</li><li>布尔值默认是false  </li><li>除了基本类型其余默认值都为null</li></ul><p> <em>变量类型 变量名字 &#x3D; new 变量()</em></p><p><strong>类变量 stasic</strong></p><p>从属于类，便于调用</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量名一般使用大写字符</p><p><strong>final 常量名 &#x3D;值</strong></p><p>final 是修饰符</p><p><em>修饰符不存在先后顺序</em></p><h1 id="面向对象-抽象-amp-面向过程-具体"><a href="#面向对象-抽象-amp-面向过程-具体" class="headerlink" title="面向对象(抽象)&amp;面向过程(具体)"></a>面向对象(抽象)&amp;面向过程(具体)</h1><ul><li><p>面向对象编程OOP</p></li><li><p>面向对象编程的本质就是:<strong>以类的方式组织代码，以对象的组织（封装）数据。</strong></p></li><li><p>抽象</p></li><li><p>三大特性</p></li><li><ul><li><p>封装</p><ul><li>追求**”高内聚，低耦合”<strong>，高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</strong>重点是对属性**</li><li><ol><li>提高程序安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>系统可维护增加</li></ol></li></ul></li><li><p>继承</p><ul><li><p>本质是对某一批类的抽象，</p></li><li><p>extends的意思就是”拓展“。子类是父类的拓展，子类会拥有父类的全部方法</p></li><li><p>JAVA中类只有单继承</p></li><li><p>ctrl+h打开关系树</p></li><li><p>super调用父类方法，必须在构造方法第一个</p></li><li><p>调用父类构造器必须在子类第一行</p></li><li><p><em>super和this不能同时调用构造方法</em></p></li><li><p>父类引用指向了子类</p></li><li><p>非静态才有重写，也只能是public，子类重写父类的方法，执行子类的方法</p></li><li><p>修饰符：范围可以扩大，不能缩小public&gt;protected&gt;default&gt;private</p></li><li><p>抛出的异常：范围，可以缩小，不能扩大</p></li><li><p>alt+insert：override；重写</p></li></ul></li><li><p>多态（同一方法根据发送对象的不同而采用多种不同的行为方式）</p><ul><li>可以只想的引用类型不确定：父类的引用指向子类</li><li>父类型，可以指向子类，但不能调用子类独有的方法</li><li>注意 1. 多态是方法的多态，属性没有多态<ol start="2"><li>父类和子类，有联系   类型转换异常！ClassCastException！</li><li>存在条件：继承关系，方法需要重写，父类引用</li></ol></li></ul></li></ul></li><li><p>从认识论角度考虑是现有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</p></li><li><p>从代码运行角度考虑是<em>现有类后有对象。类是对象的模板</em></p></li><li><p>static和类一起加载</p></li><li><p>类实例化之后才存在</p></li><li><p><font color='red'>属性私有，get&#x2F;set</font> </p></li><li></li></ul><h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h2><ul><li>类是一种抽象的数据类型，<strong>他是对某一类事物整体描述，</strong>不能代表某一具体事物</li><li>对象是抽象概念的<strong>具体实例</strong></li></ul><h2 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h2><ul><li>一个类即使什么都不屑，它也会存在一个方法</li></ul><p>构造器通常也叫构造方法、构造函数</p><h2 id="abstract抽象类（需理解）"><a href="#abstract抽象类（需理解）" class="headerlink" title="abstract抽象类（需理解）"></a>abstract抽象类（需理解）</h2><p>只有方法名字没有方法实现</p><p>抽象类所有方法，继承了它的子类，必须要实现它的方法，除非子类也是abstract</p><ol><li>不能new抽象类，只能靠子类去实现它；约束</li><li>抽象类中可以写普通的方法</li><li>抽象方法必须在抽象类中</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>只有规范，自己无法写方法~专业的约束！约束的实现和分离：面向接口编程</p><p><strong>接口的本质是契约</strong>，制定好后大家都遵守</p><p>接口声明的关键字是interface</p><p>接口中的所有定义都是抽象的 public abstract</p><p>接口中定义的属性都是常量 public static final</p><p>接口都需要实现类</p><p>![](java基础.assets&#x2F;屏幕截图 2022-10-10 080115.png)</p><p>类 可以实现（多个）接口 implements 。</p><p>实现接口的类需要重写接口中的方法</p><h2 id="0-0"><a href="#0-0" class="headerlink" title="0.0"></a>0.0</h2><ol><li><p>类与对象</p><p>类是一个模板：抽象，对象是一个具体的实例</p></li><li><p>方法</p><p>定义，调用</p></li><li><p>对应的引用</p><p>引用类型：  基本类型（8）</p><p>对象是通过引用来操作的：栈—&gt;堆</p></li><li><p>属性：字段Field 成员变量</p><p>默认初始化：</p><p>数字：0    0.0</p><p>char: u0000</p><p>boolean：false</p><p>引用：null</p><p>修饰符  属性类型  属性名  &#x3D; 属性值！</p></li><li><p>对象的创造和使用</p><ul><li>必须使用new 关键字创建对象，构造器Person    kuangshen &#x3D; new Person（）;</li><li>对象的属性 kuangshen.name</li><li>对象的方法 kuangshen.sleep()</li></ul></li><li><p>类：</p><p>静态的属性    属性</p><p>动态的行为    方法</p></li></ol><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>内部类就是在一个类的内部定义类</li><li>通过外部类来实例化内部类</li><li>内部类能获得外部类的私有属性</li><li>一个java类中可以有多个class类，但是只能有一个public calss</li><li>内部类和方法并列叫成员内部类，内部类在方法内叫做局部内部类</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组概述"><a href="#1-数组概述" class="headerlink" title="1.数组概述"></a>1.数组概述</h2><h2 id="2-数组声明创建"><a href="#2-数组声明创建" class="headerlink" title="2.数组声明创建"></a>2.数组声明创建</h2><p><img src="/pic/java%E5%9F%BA%E7%A1%80/p8.png" alt="img8"></p><p><em>首选第一个</em></p><ul><li>Java需要用new操作符来创建数组</li></ul><ol><li>声明一个数组</li><li>创建一个数组</li><li>给数组元素中赋值</li></ol><h2 id="3-数组使用"><a href="#3-数组使用" class="headerlink" title="3.数组使用"></a>3.数组使用</h2><p>4个基本特点：</p><ul><li>其<strong>长度是确定</strong>的。数组一旦被创建，他的大小就是不可以改变的。</li><li>其元素必须是<strong>相同类型</strong>，不允许出现混合类型。</li><li>数组中的元素可以是任何类型数据，包括基本类型和引用类型。</li><li>数组变量属于引用类型数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。<strong>数组本身就是对象</strong>，Java当中对象是在堆中的，因此数组无论保存还是类型还是其他对象类型，数组本身是在堆中的</li></ul><h2 id="4-多维数组"><a href="#4-多维数组" class="headerlink" title="4.多维数组"></a>4.多维数组</h2><h2 id="5-Arrays类"><a href="#5-Arrays类" class="headerlink" title="5.Arrays类"></a>5.Arrays类</h2><p>数组的工具类 java.until.Arrays</p><p>sort排序,quals比较，fill赋值，</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>见DEMO02</p><h2 id="6-稀疏数组"><a href="#6-稀疏数组" class="headerlink" title="6.稀疏数组"></a>6.稀疏数组</h2><h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>exception即异常是指程序运行中出现不期而至的各种状况，如：文件找不到，网络连接失败，非法参数等。</p><p>三种类型的异常</p><ul><li>检测性异常：</li><li>运行时异常：</li><li>错误ERROR：如栈溢出</li></ul><h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><p><img src="/pic/java%E5%9F%BA%E7%A1%80/p9.png" alt="img9"></p><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><ul><li>异常处理的五个关键字<ul><li>try，catch，finall，throw，throws</li></ul></li></ul><p>try{监控区域</p><p>}catch(想要捕获的异常类型){}</p><p>&#x2F;&#x2F;ctrl+alt+t 快捷包裹指令</p><p>throw&#x2F;&#x2F;主动抛出异常，一般在方法中使用</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a><em>自定义异常</em></h2><ol><li>创建自定义异常类型</li><li></li></ol><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><img src="/pic/java%E5%9F%BA%E7%A1%80/p10.png" alt="java语言支持的运算符"></p><ul><li>不同类型值运算结果，计算值有long则结果为long，有double为double；类型最低为int</li><li>关系运算符返回的结果是布尔值：false ture</li><li>++ – 自增 自减 一元运算符</li><li>许多运算可用工具类来操作，<em>如：Math.  <del>选择所需计算</del></em></li><li>短路运算   <em>(c&lt;4)&amp;&amp;(c++&lt;10),若c&lt;4错误，则后面运算不进行</em></li><li>A&amp;B对应位都为1才是1; <em>a&#x3D;0011 1100;b&#x3D;0000 1101,则a&amp;b&#x3D;0000 1100</em></li><li>A|B对应位有1则为1；<em>a|b&#x3D;0011 1101</em></li><li>A^B对应位相同则为0，不同为1；<em>a^b&#x3D;0011 0001</em></li><li>~B对应位取反；<em>a&#x3D;1100 0011</em></li><li>&lt;&lt;左移 <em>2，&gt;&gt;右移 &#x2F;2；*<em>效率高，与底层逻辑直接相关</em></em></li><li>a+&#x3D;b即a&#x3D;a+b 其他同理</li><li>字符串连接符+，String；<strong>字符串””在前则拼接，字符串在后则相加</strong> 区别*””+a+b与a+b+””*</li><li>条件**？: *<em>例：</em>x ? y : z 如果x&#x3D;&#x3D;ture则结果为y，否则为x*</li><li>优先级()，多使用()提高编码的可读性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java方法&quot;&gt;&lt;a href=&quot;#Java方法&quot; class=&quot;headerlink&quot; title=&quot;Java方法&quot;&gt;&lt;/a&gt;Java方法&lt;/h1&gt;&lt;h2 id=&quot;1-方法&quot;&gt;&lt;a href=&quot;#1-方法&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="Java与开发" scheme="https://nihility500.github.io/categories/Java%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="java" scheme="https://nihility500.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://nihility500.github.io/2023/04/04/hello-world/"/>
    <id>https://nihility500.github.io/2023/04/04/hello-world/</id>
    <published>2023-04-03T16:00:00.000Z</published>
    <updated>2023-04-05T05:45:47.580Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
